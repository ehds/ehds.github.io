<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="bthread调度策略探索"/><meta name="keywords" content="brpc, bthread, Ehds" /><link rel="alternate" href="/atom.xml" title="Ehds"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://ehds.github.io/2021/07/20/bthread_schedule/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>bthread调度策略探索 - Ehds</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Ehds" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ehds</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ehds</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">bthread调度策略探索
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-07-20
        </span><span class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bthread的整体架构"><span class="toc-text">Bthread的整体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bthread调度策略"><span class="toc-text">Bthread调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TaskControl"><span class="toc-text">1. TaskControl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TaskGroup"><span class="toc-text">2. TaskGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ParkingLot"><span class="toc-text">3. ParkingLot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-StealTask"><span class="toc-text">4. StealTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-两种bthread启动方式"><span class="toc-text">5. 两种bthread启动方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bthread在BRPC中的应用"><span class="toc-text">Bthread在BRPC中的应用</span></a></li></ol>
    </div>
  </div><div class="post-content"><p><a href="https://github.com/brpc/brpc/tree/master/src/bthread" target="_blank" rel="noopener">bthread</a>是brpc使用的M:N线程库，目的是在提高程序的并发度的同时，降低编码难度，并在核数日益增多的CPU上提供更好的scalability和cache locality。</p>
<a id="more"></a>

<p>bthread的M:N模型是将M个bthread映射到N个pthread，M会远大于N。如下图所示:</p>
<p>协程一般也是将多个用户线程运行在单个内核线程，但他们是N:1的关系，不同内核线程上的用户线程不共享，并且如果一个线程阻塞会导致其他线程都处于等待状态，无法利用多核。bthread的M:N模型以及steal_work的调度机制可以更好的利用多核。</p>
<h2 id="Bthread的整体架构"><a href="#Bthread的整体架构" class="headerlink" title="Bthread的整体架构"></a>Bthread的整体架构</h2><p>bthread 的整体结构如下：</p>
<p>bthread的整体架构分为<code>TaskControl</code>、<code>TaskGroup</code> 和<code>ParkingLot</code>，其中 TaskControl 为全局唯一的实例用于管理所有的TaskGroup,；TaskGroup 主要是协调 bthread 的调度，它和一个pthread 进行绑定；ParkingLot 是 bthread 调度的信号量，内部使用futex实现，用于TaskGroup的等待和唤醒。</p>
<h2 id="Bthread调度策略"><a href="#Bthread调度策略" class="headerlink" title="Bthread调度策略"></a>Bthread调度策略</h2><h3 id="1-TaskControl"><a href="#1-TaskControl" class="headerlink" title="1. TaskControl"></a>1. TaskControl</h3><p>TaskControl 是一个全局唯一的实例，当有新的bthread加入的时候，会从 TaskControl 里面选取一个 TaskGroup，并将该bthread加入到TaskGroup中，如果 TaskControl 还未初始化 TaskGroup，则开始创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_workers.resize(_concurrency);   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _concurrency; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rc = pthread_create(&amp;_workers[i], <span class="literal">NULL</span>, worker_thread, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Fail to create _workers["</span> &lt;&lt; i &lt;&lt; <span class="string">"], "</span> &lt;&lt; berror(rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 _concurrency 为指定的 workers 数量，brpc 中默认为 （8+epoll_num），创建的workers线程具体执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TaskControl* c = <span class="keyword">static_cast</span>&lt;TaskControl*&gt;(arg);</span><br><span class="line">   TaskGroup* g = c-&gt;create_group();</span><br><span class="line">   TaskStatistics stat;</span><br><span class="line">.....</span><br><span class="line">   tls_task_group = g;</span><br><span class="line">   c-&gt;_nworkers &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   g-&gt;run_main_task();</span><br></pre></td></tr></table></figure>
<p>每个 worker 首先创建一个 TaskGroup，并执行该 task_group 的run_main_task。<br /></p>
<p><a name="E4jxF"></a></p>
<h3 id="2-TaskGroup"><a href="#2-TaskGroup" class="headerlink" title="2. TaskGroup"></a>2. TaskGroup</h3><p>TaskGroup 主要用于协调bthread的调度执行，入口为run_main_task:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskGroup::run_main_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    TaskGroup* dummy = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">bthread_t</span> tid;</span><br><span class="line">    <span class="keyword">while</span> (wait_task(&amp;tid)) &#123;</span><br><span class="line">        TaskGroup::sched_to(&amp;dummy, tid);</span><br><span class="line">        DCHECK_EQ(<span class="keyword">this</span>, dummy);</span><br><span class="line">        DCHECK_EQ(_cur_meta-&gt;<span class="built_in">stack</span>, _main_stack);</span><br><span class="line">        <span class="keyword">if</span> (_cur_meta-&gt;tid != _main_tid) &#123;</span><br><span class="line">            TaskGroup::task_runner(<span class="number">1</span><span class="comment">/*skip remained*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断的 wait_task, 等到 bthread 后，即进入 sched_to 开始调度该 bthread。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskGroup::sched_to</span><span class="params">(TaskGroup** pg, TaskMeta* next_meta)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">	......</span><br><span class="line">    TaskMeta* <span class="keyword">const</span> cur_meta = g-&gt;_cur_meta;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (cur_meta-&gt;<span class="built_in">stack</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next_meta-&gt;<span class="built_in">stack</span> != cur_meta-&gt;<span class="built_in">stack</span>) &#123;</span><br><span class="line">                jump_stack(cur_meta-&gt;<span class="built_in">stack</span>, next_meta-&gt;<span class="built_in">stack</span>);</span><br><span class="line">                <span class="comment">// probably went to another group, need to assign g again.</span></span><br><span class="line">                g = tls_task_group;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// else pthread_task is switching to another pthread_task, sc</span></span><br><span class="line">                <span class="comment">// can only equal when they're both _main_stack</span></span><br><span class="line">                CHECK(cur_meta-&gt;<span class="built_in">stack</span> == g-&gt;_main_stack);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else because of ending_sched(including pthread_task-&gt;pthread_task)</span></span><br><span class="line">    &#125; </span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (g-&gt;_last_context_remained) &#123;</span><br><span class="line">        RemainedFn fn = g-&gt;_last_context_remained;</span><br><span class="line">        g-&gt;_last_context_remained = <span class="literal">NULL</span>;</span><br><span class="line">        fn(g-&gt;_last_context_remained_arg);</span><br><span class="line">        g = tls_task_group;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sched_to 主要的步骤即把当前的bthread的所保存的上下文内容（利用_boost::context _生成的）加载到当前的线程栈中，并跳转到bthread的执行位置开始执行。当前的 bthread 执行完成后，会把之前停留的一些任务执行完，然后进入ending_sched:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskGroup::ending_sched</span><span class="params">(TaskGroup** pg)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">    <span class="keyword">bthread_t</span> next_tid = <span class="number">0</span>;</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// getting next bthread from _rq</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> popped = g-&gt;_rq.pop(&amp;next_tid);</span><br><span class="line">    <span class="keyword">if</span> (!popped &amp;&amp; !g-&gt;steal_task(&amp;next_tid)) &#123;</span><br><span class="line">        <span class="comment">// Jump to main task if there's no task to run.</span></span><br><span class="line">        next_tid = g-&gt;_main_tid;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskMeta* <span class="keyword">const</span> cur_meta = g-&gt;_cur_meta;</span><br><span class="line">    TaskMeta* next_meta = address_meta(next_tid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (next_meta-&gt;<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        ContextualStack* stk = get_stack(next_meta-&gt;stack_type(), task_runner);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    sched_to(pg, next_meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ending_sched 主要是当前bthread执行完后会优先从本地获取下一个bthread，如果没有则从其他taskgroup偷取bthread来执行，获取成功后又重新调度。如果没有获取到bthread则进入main_task开始等待。整体流程如下：</p>
<h3 id="3-ParkingLot"><a href="#3-ParkingLot" class="headerlink" title="3. ParkingLot"></a>3. ParkingLot</h3><p>ParkingLot 作为 TaskGroup 获取 bthread 的信号量，内部使用futex实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up at most `num_task' workers.</span></span><br><span class="line">  <span class="comment">// Returns #workers woken up.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> num_task)</span> </span>&#123;</span><br><span class="line">      _pending_signal.fetch_add((num_task &lt;&lt; <span class="number">1</span>), butil::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> futex_wake_private(&amp;_pending_signal, num_task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a state for later wait().</span></span><br><span class="line">  <span class="function">State <span class="title">get_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _pending_signal.load(butil::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for tasks.</span></span><br><span class="line">  <span class="comment">// If the `expected_state' does not match, wait() may finish directly.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">const</span> State&amp; expected_state)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//LOG(FATAL) &lt;&lt; _pending_signal &lt;&lt; expected_state.val ;</span></span><br><span class="line">      futex_wait_private(&amp;_pending_signal, expected_state.val, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>parking_lot 的等待与唤醒都是利用系统调用 futex_wait 和 futex_wake 来实现，futex 的优势在于 wait 时会先判断当前的pending_signal 是否和 expected_state 的值相等，如果不相等则直接返回，不必进入内核态，减少开销。具体原理参考<a href="https://www.man7.org/linux/man-pages/man2/futex.2.html" target="_blank" rel="noopener">futex — Linux manual page</a>。为了减少竞争，在bthread中默认有4个pariking_lot, 每个TaskGroup会与其中一个parking_lot对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_pl = &amp;c-&gt;_pl[butil::fmix64(pthread_numeric_id()) % TaskControl::PARKING_LOPART_NUM];</span><br></pre></td></tr></table></figure>

<p>每个task_group会根据当前的pthread_numeric_id来分配parking_lot，这样在一定程度上会减少一定的竞争。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PARKING_LOT_NUM = <span class="number">4</span>;</span><br><span class="line">ParkingLot _pl[PARKING_LOT_NUM];</span><br></pre></td></tr></table></figure>

<p>PARKING_LOPART_NUM 在 bthread 中为常量，不可调节。PARKING_LOT_NUM 不同值在不同的情况下会不会成为瓶颈有待验证。当有新的bthread加入的时候，如果设置了signal参数，则会调用TaskControl的signal_task唤醒任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskControl::signal_task</span><span class="params">(<span class="keyword">int</span> num_task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num_task &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(gejun): Current algorithm does not guarantee enough threads will</span></span><br><span class="line">    <span class="comment">// be created to match caller's requests. But in another side, there's also</span></span><br><span class="line">    <span class="comment">// many useless signalings according to current impl. Capping the concurrency</span></span><br><span class="line">    <span class="comment">// is a good balance between performance and timeliness of scheduling.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        num_task = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start_index = butil::fmix64(pthread_numeric_id()) % PARKING_LOT_NUM;</span><br><span class="line">    num_task -= _pl[start_index].signal(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; PARKING_LOT_NUM &amp;&amp; num_task &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++start_index &gt;= PARKING_LOT_NUM) &#123;</span><br><span class="line">                start_index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num_task -= _pl[start_index].signal(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        FLAGS_bthread_min_concurrency &gt; <span class="number">0</span> &amp;&amp;    <span class="comment">// test min_concurrency for performance</span></span><br><span class="line">        _concurrency.load(butil::memory_order_relaxed) &lt; FLAGS_bthread_concurrency) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Reduce this lock</span></span><br><span class="line">        BAIDU_SCOPED_LOCK(g_task_control_mutex);</span><br><span class="line">        <span class="keyword">if</span> (_concurrency.load(butil::memory_order_acquire) &lt; FLAGS_bthread_concurrency) &#123;</span><br><span class="line">            add_workers(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>signal_task 用于唤醒等待的 workers，为了减少无用的唤醒，会做一个限制，每次唤醒的次数最多2个，如果2个都未唤醒成功，并且设置了FLAGS_bthread_min_concurrency, 则会加入新的 worker 以满足当前的并发量。</p>
<h3 id="4-StealTask"><a href="#4-StealTask" class="headerlink" title="4. StealTask"></a>4. StealTask</h3><p>在 TaskGroup 中有两个用于存储 bthread 的队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WorkStealingQueue&lt;<span class="keyword">bthread_t</span>&gt; _rq;</span><br><span class="line">RemoteTaskQueue _remote_rq;</span><br></pre></td></tr></table></figure>

<p>其中 WorkStealingQueue 用于存储由 task_group(worker) 自身生成的 bthread，RemoteTaskQueue 用于存储非 task_group 生成的bthread，因为 WorkStealingQueue 中的 push 和 pop 只会被本 worker 调用，仅与 steal 产生竞争，所以使用无锁实现减少锁的开销。RemoteTaskQueue 由于是由非 worker 调用，且是随机选择task_group, 所以使用锁的方式实现。StealTask 是 brpc 里调度bthread 的策略，即可以从其他 task_group(worker) 的队列里面去拿任务，是实现 $M:N$ 模型的方法。</p>
<ol>
<li><p>被唤醒时会触发steal_task<br>worker wait 的前提是本身队列没有任务，且未能偷到任务，所以当唤醒时，会触发 steal_task 去拿任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_pl-&gt;wait(_last_pl_state);</span><br><span class="line">LOG(FATAL) &lt;&lt; <span class="string">"start steal task"</span>;</span><br><span class="line"><span class="keyword">if</span> (steal_task(tid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ending_sched时可能触发steal_task</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BTHREAD_FAIR_WSQ</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> popped = g-&gt;_rq.pop(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> popped = g-&gt;_rq.steal(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!popped &amp;&amp; !g-&gt;steal_task(&amp;next_tid)) &#123;</span><br><span class="line">        <span class="comment">// Jump to main task if there's no task to run.</span></span><br><span class="line">        next_tid = g-&gt;_main_tid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果本 taskgroup 的 _rq 没有任务时，就会触发 steal_task。task_group 的 steal_task 会首先从本地的 _remote_rq 取任务，如果没有则会从其他 task_group 拿任务。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">steal_task</span><span class="params">(<span class="keyword">bthread_t</span>* tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_remote_rq.pop(tid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BTHREAD_DONT_SAVE_PARKING_STATE</span></span><br><span class="line">        _last_pl_state = _pl-&gt;get_state();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> _control-&gt;steal_task(tid, &amp;_steal_seed, _steal_offset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过 task_control 这个管理者实现从其他 task_group 拿任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> stolen = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">size_t</span> s = *seed;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngroup; ++i, s += offset) &#123;</span><br><span class="line">    TaskGroup* g = _groups[s % ngroup];</span><br><span class="line">    <span class="comment">// g is possibly NULL because of concurrent _destroy_group</span></span><br><span class="line">    <span class="keyword">if</span> (g) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;_rq.steal(tid)) &#123;</span><br><span class="line">            stolen = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;_remote_rq.pop(tid)) &#123;</span><br><span class="line">            stolen = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即从随机位置开始遍历，每次跨度 offset，遍历 ngroup 次，先从其他 task_group 的 working_stealing_queue 里面取，其次从remote_rq 取，取到任务后立即返回。</p>
<p><strong>从上面分析中可以看出，如果开启很多task_group后，每个task_group任务消耗完后会产生大量的steal_task调用。如果工作的负载处于波动的情况下，处于波峰的时候会拉起很多task_group工作，到达波谷时task_group会发生大量的steal_work，而如果负载一直处于较低或较高的状态，steal_work调用会显著降低。</strong></p>
<h3 id="5-两种bthread启动方式"><a href="#5-两种bthread启动方式" class="headerlink" title="5. 两种bthread启动方式"></a>5. 两种bthread启动方式</h3><p>在 bthrea d中有两种方式开启新的 bthread：</p>
<ol>
<li><p>bthread_start_background</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bthread_start_background</span><span class="params">(<span class="keyword">bthread_t</span>* __restrict tid,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span> * (*fn)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span>* __restrict arg)</span> </span>&#123;</span><br><span class="line">    bthread::TaskGroup* g = bthread::tls_task_group;</span><br><span class="line">    <span class="keyword">if</span> (g) &#123;</span><br><span class="line">        <span class="comment">// start from worker</span></span><br><span class="line">        <span class="keyword">return</span> g-&gt;start_background&lt;<span class="literal">false</span>&gt;(tid, attr, fn, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bthread::start_from_non_worker(tid, attr, fn, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果创建这个bthread的调用者是外部的线程（非task_group），调用start_from_non_worker。<br>start_from_non_worker的工作就是从task_control随机选择一个task_group作为这个新bthread的归宿。</p>
</li>
<li><p>如果创建者是已经存在于task_group的bthread则会以当前的task_group作为最终归宿。<br>task_group中的start_background做的工作就是为新的bthread创建资源TaskMeta，然后根据上面两种情况分别加入不同的对列，情况1 加入 remote_rq, 情况2 加入 _rq 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (REMOTE) &#123;</span><br><span class="line">    ready_to_run_remote(m-&gt;tid, (using_attr.flags &amp; BTHREAD_NOSIGNAL));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ready_to_run(m-&gt;tid, (using_attr.flags &amp; BTHREAD_NOSIGNAL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bthread_start_urgent<br>如果调用者是外部的线程则和上面分析一致，如果调用者是已经存在的task_group 的 bthread，则会调用当前 task_group 的start_foreground</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TaskGroup::start_foreground</span><span class="params">(TaskGroup** pg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bthread_t</span>* __restrict th,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> * (*fn)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span>* __restrict arg)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// initialize task meta</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;is_current_pthread_task()) &#123;</span><br><span class="line">        g-&gt;ready_to_run(m-&gt;tid, (using_attr.flags &amp; BTHREAD_NOSIGNAL));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NOSIGNAL affects current task, not the new task.</span></span><br><span class="line">        RemainedFn fn = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;current_task()-&gt;about_to_quit) &#123;</span><br><span class="line">            fn = ready_to_run_in_worker_ignoresignal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fn = ready_to_run_in_worker;</span><br><span class="line">        &#125;</span><br><span class="line">        ReadyToRunArgs args = &#123;</span><br><span class="line">            g-&gt;current_tid(),</span><br><span class="line">            (<span class="keyword">bool</span>)(using_attr.flags &amp; BTHREAD_NOSIGNAL)</span><br><span class="line">        &#125;;</span><br><span class="line">        g-&gt;set_remained(fn, &amp;args);</span><br><span class="line">        TaskGroup::sched_to(pg, m-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先也是初始化 taskmeta，用于后续的调度，由于是 start_foreground，当前的task如果还未完成，则会在后续调用read_ro_run_in_worker，将当前未完成的 bthread 加入队列中，该逻辑封装在 RemainedFn 中。然后调用sched_to 调度当前新的 bthread。新的bthread会被包裹在 task_runner 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskGroup::task_runner</span><span class="params">(<span class="keyword">intptr_t</span> skip_remained)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> tls_task_group is volatile since tasks are moved around</span></span><br><span class="line">    <span class="comment">//       different groups.</span></span><br><span class="line">    TaskGroup* g = tls_task_group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skip_remained) &#123;</span><br><span class="line">        <span class="keyword">while</span> (g-&gt;_last_context_remained) &#123;</span><br><span class="line">            RemainedFn fn = g-&gt;_last_context_remained;</span><br><span class="line">            g-&gt;_last_context_remained = <span class="literal">NULL</span>;</span><br><span class="line">            fn(g-&gt;_last_context_remained_arg);</span><br><span class="line">            g = tls_task_group;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        --g-&gt;_sched_recursive_guard;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">void</span>* thread_return;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread_return = m-&gt;fn(m-&gt;arg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExitException&amp; e) &#123;</span><br><span class="line">            thread_return = e.value();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Group is probably changed</span></span><br><span class="line">        g = tls_task_group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Save thread_return</span></span><br><span class="line">        (<span class="keyword">void</span>)thread_return;</span><br><span class="line"></span><br><span class="line">     	......</span><br><span class="line">        g-&gt;_control-&gt;_nbthreads &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        g-&gt;set_remained(TaskGroup::_release_last_context, m);</span><br><span class="line">        ending_sched(&amp;g);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (g-&gt;_cur_meta-&gt;tid != g-&gt;_main_tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先就是调用 remain 函数（上面的将未完成的bthread加入队列），接着完成当前 bthread 具体的函数（fn），最终进入 ending_sched 调度下一个任务直到没有任务，然后进入 main_tid。</p>
</li>
</ol>
<h2 id="Bthread在BRPC中的应用"><a href="#Bthread在BRPC中的应用" class="headerlink" title="Bthread在BRPC中的应用"></a>Bthread在BRPC中的应用</h2><p>BRPC 是百度开源的一款 rpc 框架，内部使用了Bthread的线程模型brpc 的流程大致如下：</p>
<p>EventDispatcher 主要利用 epoll 监听读写事件，并分发事件到相应的处理handler。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeGlobalDispatchers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g_edisp = <span class="keyword">new</span> EventDispatcher[FLAGS_event_dispatcher_num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FLAGS_event_dispatcher_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bthread_attr_t</span> attr = FLAGS_usercode_in_pthread ?</span><br><span class="line">            BTHREAD_ATTR_PTHREAD : BTHREAD_ATTR_NORMAL;</span><br><span class="line">        CHECK_EQ(<span class="number">0</span>, g_edisp[i].Start(&amp;attr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This atexit is will be run before g_task_control.stop() because above</span></span><br><span class="line">    <span class="comment">// Start() initializes g_task_control by creating bthread (to run epoll/kqueue).</span></span><br><span class="line">    CHECK_EQ(<span class="number">0</span>, atexit(StopAndJoinGlobalDispatchers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化时，会开启 event_dispatcher_num（默认为1）个disaptcher，运行在 bthread 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_LINUX)</span></span><br><span class="line">            <span class="keyword">if</span> (e[i].events &amp; (EPOLLIN | EPOLLERR | EPOLLHUP)</span><br><span class="line">#ifdef BRPC_SOCKET_HAS_EOF</span><br><span class="line">                || (e[i].events &amp; has_epollrdhup)</span><br><span class="line">#endif</span><br><span class="line">                ) &#123;</span><br><span class="line">                <span class="comment">// We don't care about the return value.</span></span><br><span class="line">                Socket::StartInputEvent(e[i].data.u64, e[i].events,</span><br><span class="line">                                        _consumer_thread_attr);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e[i].events &amp; (EPOLLOUT | EPOLLERR | EPOLLHUP)) &#123;</span><br><span class="line">        <span class="comment">// We don't care about the return value.</span></span><br><span class="line">        Socket::HandleEpollOut(e[i].data.u64);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断的读取发生的读写事件并交由处理函数处理。<br>如果是发生读事件，会抢占当前 epoll 所在 task_group 的执行权限，会调用bthread_start_ugrent来执行读事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::StartInputEvent</span><span class="params">(SocketId id, <span class="keyword">uint32_t</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">bthread_attr_t</span>&amp; thread_attr)</span> </span>&#123;</span><br><span class="line">    SocketUniquePtr s;</span><br><span class="line">    <span class="keyword">if</span> (Address(id, &amp;s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == s-&gt;_on_edge_triggered_events) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	......</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;_nevent.fetch_add(<span class="number">1</span>, butil::memory_order_acq_rel) == <span class="number">0</span>) &#123;</span><br><span class="line">        g_vars-&gt;neventthread &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bthread_t</span> tid;</span><br><span class="line">        <span class="comment">// transfer ownership as well, don't use s anymore!</span></span><br><span class="line">        Socket* <span class="keyword">const</span> p = s.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bthread_attr_t</span> attr = thread_attr;</span><br><span class="line">        attr.keytable_pool = p-&gt;_keytable_pool;</span><br><span class="line">        <span class="keyword">if</span> (bthread_start_urgent(&amp;tid, &amp;attr, ProcessEvent, p) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Fail to start ProcessEvent"</span>;</span><br><span class="line">            ProcessEvent(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bthread_start_urgent 会调用 bthread 中的start_foreground，当前正在执行的 bthread 会被挂起到 _rq 队列中（可以被其他 task_group steal_task ），读事件 handler 的 btrhead 会被调度到当前task_group中（发生上下文切换 ）。在brpc中读事件一般分为两种：</p>
<ol>
<li><p>新的请求连接（OnNewConnections）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SocketId socket_id;</span><br><span class="line">SocketOptions options;</span><br><span class="line">options.keytable_pool = am-&gt;_keytable_pool;</span><br><span class="line">options.fd = in_fd;</span><br><span class="line">options.remote_side = butil::EndPoint(*(sockaddr_in*)&amp;in_addr);</span><br><span class="line">options.user = acception-&gt;user();</span><br><span class="line">options.on_edge_triggered_events = InputMessenger::OnNewMessages;</span><br><span class="line">options.initial_ssl_ctx = am-&gt;_ssl_ctx;</span><br><span class="line"><span class="keyword">if</span> (Socket::Create(options, &amp;socket_id) != <span class="number">0</span>) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Fail to create Socket"</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得远端的 socket 的信息并创建新的 socket_id, 并将读事件的handler 设置为 OnNewMessages</p>
</li>
<li><p>读socket上的message (OnNewMessages)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputMessenger::OnNewMessages</span><span class="params">(Socket* m)</span> </span>&#123;</span><br><span class="line">    InputMessenger* messenger = <span class="keyword">static_cast</span>&lt;InputMessenger*&gt;(m-&gt;user());</span><br><span class="line">    <span class="keyword">const</span> InputMessageHandler* handlers = messenger-&gt;_handlers;</span><br><span class="line">    <span class="keyword">int</span> progress = Socket::PROGRESS_INIT;</span><br><span class="line">    <span class="keyword">while</span> (!read_eof) &#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">        <span class="comment">// Read.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">ssize_t</span> nr = m-&gt;DoRead(once_read);</span><br><span class="line">        ......</span><br><span class="line">        m-&gt;AddInputBytes(nr);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> index = <span class="number">8888</span>;</span><br><span class="line">            ParseResult pr = messenger-&gt;CutInputMessage(m, &amp;index, read_eof);</span><br><span class="line">         ......</span><br><span class="line">            m-&gt;AddInputMessages(<span class="number">1</span>);</span><br><span class="line">    		......</span><br><span class="line">            <span class="function">DestroyingPtr&lt;InputMessageBase&gt; <span class="title">msg</span><span class="params">(pr.message())</span></span>;</span><br><span class="line">            QueueMessage(last_msg.release(), &amp;num_bthread_created,</span><br><span class="line">                             m-&gt;_keytable_pool);</span><br><span class="line">            <span class="keyword">if</span> (handlers[index].process == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"process of index="</span> &lt;&lt; index &lt;&lt; <span class="string">" is NULL"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m-&gt;ReAddress(&amp;msg-&gt;_socket);</span><br><span class="line">            m-&gt;PostponeEOF();</span><br><span class="line">            msg-&gt;_process = handlers[index].process;</span><br><span class="line">            msg-&gt;_arg = handlers[index].arg;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">if</span> (num_bthread_created) &#123;</span><br><span class="line">            bthread_flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read_eof) &#123;</span><br><span class="line">        m-&gt;SetEOF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OnNewMessages 主要是从 sokcet 上读取消息，解析消息（协议、内容等），并且将要处理的任务（用户逻辑代码）先放入队列中（QueueMessage，生成bthread，但是不signal），最终会将解析到的多个请求一并 flush（signal 所有未被signal的任务），减少不必要的开销。<br />当用户处理完逻辑后，会向soket发起写事件。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::Write</span><span class="params">(butil::IOBuf* data, <span class="keyword">const</span> WriteOptions* options_in)</span> </span>&#123;</span><br><span class="line">    WriteOptions opt;</span><br><span class="line">    <span class="keyword">if</span> (options_in) &#123;</span><br><span class="line">        opt = *options_in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> SetError(opt.id_wait, EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    WriteRequest* req = butil::get_object&lt;WriteRequest&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!req) &#123;</span><br><span class="line">        <span class="keyword">return</span> SetError(opt.id_wait, ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req-&gt;data.swap(*data);</span><br><span class="line">    <span class="comment">// Set `req-&gt;next' to UNCONNECTED so that the KeepWrite thread will</span></span><br><span class="line">    <span class="comment">// wait until it points to a valid WriteRequest or NULL.</span></span><br><span class="line">    req-&gt;next = WriteRequest::UNCONNECTED;</span><br><span class="line">    req-&gt;id_wait = opt.id_wait;</span><br><span class="line">    req-&gt;set_pipelined_count_and_user_message(</span><br><span class="line">        opt.pipelined_count, DUMMY_USER_MESSAGE, opt.with_auth);</span><br><span class="line">    <span class="keyword">return</span> StartWrite(req, opt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将写事件封装为WriteRequest请求，并加入到链表中，然后开始StartWrite，StartWrite的逻辑就是不断的将buffer中的数据写完到socket中，如果在当前bthread中能够写完数据则成功返回，否则则加入keepwrite中，开启bthread继续写，直到写完数据。</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://ehds.github.io">DongSheng</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://ehds.github.io/2021/07/20/bthread_schedule/">http://ehds.github.io/2021/07/20/bthread_schedule/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/brpc/">brpc</a>
            <a href="/tags/bthread/">bthread</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2021/06/13/silt-entropy-encoding-explain/">
        <span class="next-text nav-default">SILT 论文中关于 Entropy coding 的解释</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="gitalk-container"></div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:ehds@qq.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/ehds" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">DongSheng</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'b75057216cc9401f28a0',
    clientSecret: '6089f1aac89dc7f55aa1cceab307a61e85399bfc',
    repo: 'ehds.github.io',
    owner: 'ehds',
    admin: ['ehds'],
    id: md5(location.pathname),
    
      language: 'en',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
